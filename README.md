# SKN03-3rd-2Team
## 팀명 : 텔레핑 팀
### 팀원 소개
<table align="center">
  <tbody>
    <tr>
      <td align="center">
        <div>
          <img src="https://postfiles.pstatic.net/MjAyMjA0MjVfNTUg/MDAxNjUwODU3MDg5NTIx.kAFY5uZvlD3AbRl8S9VJkXALuMakD1uycza5bIdMD1cg.pRKUye_2R4OqDusV9J_vdmrs2xoSTnY8rAWU2u8p9osg.PNG.hanggae38/%ED%95%98%EC%B8%84%ED%95%91.png?type=w966"width="100px;"height="100px;" alt=""/>
          <a href="https://github.com/qjrm1430"><div align=center>팀장 중헌핑</div></a>
          <div>데이터 분석 및 모델링</div>
          <div>프로젝트 관리</div>
        </div>
      </td>
      <td align="center">
        <div>
          <img src="https://postfiles.pstatic.net/MjAyMjA0MjVfMTUx/MDAxNjUwODU3MDY5NzI5.aLx3BmW3RL9lEXKHWtOSJD9xYQ4AmGBTgcYW_pt0gXkg.kk0TkRqs_w77Yr9ddGR6un7r8f0NK-iDWPojNSCLzQwg.PNG.hanggae38/%EC%BD%94%EC%9E%90%ED%95%91.png?type=w966"width="100px;"height="100px;" alt=""/>
          <a href="https://github.com/min3009"><div align=center>원철핑</div></a>
          <div>데이터 분석 페이지 화면 구현</div>
          <div>Git 관리</div>
        </div>
      </td>
      <td align="center">
        <div>
          <img src="https://postfiles.pstatic.net/MjAyMjA0MjVfMTUz/MDAxNjUwODU3MDI5OTQ1.8Rt6_y66MwW8DMQUkziwchJ3NX1leGMZpOQ9xn2s9mAg.mKliXbMFNabDW5bb6X84VD_lT38ybgFI-8sIZaCuM7Ug.PNG.hanggae38/%EB%96%A0%EB%B2%8C%ED%95%91.png?type=w966"width="100px;"height="100px;" alt=""/>
          <a href="https://github.com/Jamesmoon00"><div align=center>건우핑</div></a>
          <div>예측 페이지 화면 구현</div>
        </div>
      </td>
      <td align="center">
        <div>
          <img src="https://postfiles.pstatic.net/MjAyMjA0MjVfMzUg/MDAxNjUwODU3MDU0Njky.GHiQSrE7HYFqMsqfWzb9MHmJJqNtjxUWyBDXUfYqtxwg.neElAaHNinCFi7WB5z7uNUWZ5t7kQfxte5kpKRoEMHQg.PNG.hanggae38/%EC%95%84%EC%9E%90%ED%95%91.png?type=w966"width="100px;"height="100px;" alt=""/>
            <a href="https://github.com/Theeojeong"><div align=center>재현핑</div></a>
            <div>모델 성능 평가 페이지 화면 구현</div>
        </div>
      </td>
      <td align="center">
        <div>
          <img src="https://postfiles.pstatic.net/MjAyMjA0MjVfMjc0/MDAxNjUwODU3MDI5MTQz.9Gqybmqt_7KbBQ25Uq0nBmUSruMjLvcoJt6hf1TpZWsg.DIXltCOkvbJxQnjUfY5l2ZarsEZ2U1G0mlQIUQKg3oYg.PNG.hanggae38/%EB%94%B0%EB%9D%BC%ED%95%91.png?type=w966"width="100px;"height="100px;" alt=""/>
          <a href="https://github.com/5-lee"><div align=center>준석핑</div></a>
          <div>데이터 분석</div>
        </div>
      </td>
    </tr>
  </tbody>
</table>

## 1. 프로젝트 개요 
### 개발 기간 
2024-09-13 ~ 2024-09-24

### 프로젝트 명 
📊<b>고객 이탈 분석 및 예측 시스템</b>📊

### 프로젝트 소개 
저희 '텔레핑'은 고객 데이터를 분석하여 이탈 위험이 높은 고객을 예측하고, 고객의 이탈을 방지할 수 있는 맞춤형 전략을 제안합니다. <br>
우리의 목표는 기업의 고객 유지율을 극대화하고, 이탈 고객의 원인을 파악하여 더 나은 서비스와 마케팅 전략을 수립하는데 초점을 두었습니다. <br>
이를 통해 기업의 수익성을 높이며, 고객 관계를 강화하는 데 기여하고자 합니다.

### 프로젝트 목표 
- **🔍 고객 행동 패턴 분석 🔍**: 고객의 가입 형태, 사용 패턴, 서비스 이용 빈도 등을 분석하여 이탈 가능성이 높은 고객 그룹을<br> 
식별하고, 그들의 특성을 파악하여 맞춤형 서비스를 제공합니다.

- **❗ 이탈 원인 분석 ❗**: 고객 이탈의 주요 원인을 분석하여, 고객이 이탈하는 이유를 이해하고 그에 따른 대응 전략을 세워 <br>
이탈률을 줄이는 방안을 모색합니다.

- **📈 고객 유지 캠페인 최적화 📈**: 이탈 방지를 위한 유지 캠페인을 효과적으로 운영할 수 있도록, 다양한 고객 그룹에 맞춘 <br>
마케팅 캠페인과 서비스 개선을 추천합니다.

## 2. 아키텍처
![telco drawio](https://github.com/user-attachments/assets/1185cb4d-bf2d-4d27-ba8b-0e3ec0a5daff)


## 3. 주요 분석 내용 
   ### 1. 전체 데이터 확인 및 타겟 데이터분석
   -**연속형 데이터**: 가입기간, 월 청구금액, 총 청구금액으로 구성
   -**범주형 데이터**: 고객의 특성, 온라인 및 기타 서비스 사용, 전화 및 인터넷 서비스 사용, 계약 및 결제 관련 데이터로 분류가 가능
   -**타겟 데이터**: 이탈율로 약 26.5%의 이탈율을 가짐
   
   ### 2. 데이터 전처리
   - **`SeniorCitizen`**: (고유값: 2) → 범주형으로 변환
   - **`TotalCharges`**: 현재 object 타입이므로, 수치형(float)으로 변환하는 것이 적합 <br>
   이 과정에서 결측치가 11개 생김
   - **TotalCharges 컬럼의 결측값 처리 방안** : 주어진 데이터에서 TotalCharges 컬럼의 결측치가 11개에 불과하다는 점을 고려하면, 평균값으로 결측치를 대체하는 것이 합리적인 선택<br>결측치가 전체 데이터에서 차지하는 비율이 매우 적기 때문에, 평균값으로 채워도 데이터 분포에 큰 영향을 미치지 않을것으로 판단.

   ### 3. **수치형 데이터 분석**
   - **VS Churn**: 수치형 데이터의 박스플롯, 상관관계, 왜도 및 첨도 분석
   - **결론**: 이탈한 고객은 대체로 짧은 서비스 기간과 높은 월 청구 금액을 보인다. <br>
   이탈하지 않은 고객은 서비스 가입 기간이 길고, 총 청구 금액이 많으며 변동성도 크다.<br>
   이탈 고객의 변동성(표준편차)이 더 작다는 점은, 이탈 고객이 더 일정한 패턴을 가진다는 점을 시사한다.
   
   ### 4. **범주형 데이터 분석**
   - **변수그룹화**: 고객특성, 전화 및 인터넷 서비스, 온라인 및 기타 부가 서비스, 계약 및 결제관련, **이탈율(타겟)** 으로 그룹화
   - **VS Churn**: 각 그룹별 이탈율과의 비교한 결과 고령자, 배우자 및 부양가족이 없는 고객, Fiber optic 사용자, 온라인 보안 및 기술 지원 서비스를 사용하지 않는 고객, 월 단위 계약 및 전자 청구서를 사용하는 고객에서 이탈율이 높은 것을 확인
   - **상관관계분석**: Cramér's V 계산함수 사용해 타겟 데이터와의 상관관계 분석
   - **상위 5개 중요한 피쳐**:`Contract`, `OnlineSecurity`, `TechSupport`, `InternetService`, `PaymentMethod`
   ### 5. **클러스터링**
   - **K-means 클러스터링**: Elbow, 실루엣점수, BIC점수를 통해 최적의 **K=3** 찾음.
   
   - **PCA**: 2차원으로 축소후 시각화 한 결과 cluster2 집합군의 이탈율이 가장 높은것으로 나타남
   
   - **Cluster2 VS Churn**: Cluster2와 이탈율을 비교 분석한 결과
   
      - **인터넷 서비스(InternetService)**: 64.0%의 고객이 Fiber optic을 사용하고 있으며, 나머지 36.0%는 DSL을 사용 중임.
      - **온라인 보안(OnlineSecurity)**: 64.1%의 고객이 온라인 보안을 사용하지 않음.
      - **온라인 백업(OnlineBackup)**: 55.7%의 고객이 온라인 백업 서비스를 사용하지 않음.
      - **기기 보호(DeviceProtection)**: 56.2%의 고객이 기기 보호 서비스를 사용하지 않음.
      - **기술 지원(TechSupport)**: 63.7%의 고객이 기술 지원 서비스를 사용하지 않음.
      - **계약 유형(Contract)**: 61.5%의 고객이 월 단위 계약을 사용하고 있으며, 이는 이탈율이 높은 주 원인이 될 수 있음.
      - **결제 방식(PaymentMethod)**: 전자 수표 사용 고객이 41.7%로 가장 많음.
      - **가입 기간(tenure)**: 평균 가입 기간이 33개월로, 상대적으로 중간 정도의 기간을 유지하고 있음.
      - **월 요금(MonthlyCharges)**: 월 평균 요금이 81.76달러로, 비교적 높은 요금제를 사용하는 고객들이 포함됨.
      - **총 지출(TotalCharges)**: 평균 총 지출이 2902.09달러로, 기존 고객으로서 상당한 지출을 한 상태임.


   ### 💡 고객 유지 전략 제안
   - **장기 계약 혜택 제공**: 월 단위 계약을 사용하는 고객들이 장기 계약을 선택하도록 유도합니다. 이를 위해 장기 계약을 선택할 때 추가 혜택이나 할인을 제공하여, 고객이 장기 계약으로 전환할 동기를 부여합니다.

   - **패키지 서비스 제안**: 온라인 보안, 기술 지원, 기기 보호와 같은 추가 서비스를 묶음으로 제공하여, 고객이 더 많은 부가 서비스를 사용할 수 있도록 유도합니다. 이를 통해 고객의 서비스 만족도를 높이고 이탈 가능성을 줄입니다.

   - **자동 결제 유도**: 전자 수표(Electronic check)를 사용하는 고객들의 이탈율이 높으므로, 자동 이체나 신용카드 결제와 같은 간편한 결제 방식을 제안하여 고객의 결제 불편을 해소하고 이탈을 방지합니다.

   - **요금 할인 또는 보상 프로그램**: 높은 요금으로 인해 이탈할 가능성이 있는 고객들에게 요금 할인이나 보상 프로그램을 제공하여 요금 부담을 줄입니다. 이를 통해 고객이 서비스를 지속적으로 이용할 수 있도록 유도합니다.

   ### 🧪 시뮬레이션을 통한 전략 검증
   - **전략 적용 후 이탈율 비교**: 전략을 적용한 수정된 데이터를 원본 데이터와 비교하여, 고객 유지 전략의 효과를 검증하고 이탈율 변화를 분석합니다.
   
   - **이탈 방지 전략에 따른 데이터 수정1**

      - **Fiber optic 사용자의 월 요금 10% 할인**
      - **온라인 보안을 사용하지 않는 고객 중 15%에게 보안 제공 (No -> Yes)**
      - **온라인 백업 및 기기 보호를 사용하지 않는 고객 중 15%에게 두 서비스 제공 (No -> Yes)**
      - **월 단위 계약을 사용하는 고객 중 15%를 1년 계약으로 전환**
      - **전자 수표를 사용하는 고객 중 15%를 신용카드/자동이체로 전환**
      - **기술 지원을 사용하지 않는 고객 중 15%에게 기술 지원 제공 (No -> Yes)**
      - **가입 기간이 24개월 이상인 고객의 월 요금 10% 할인**
      - **가입 기간이 6개월 이하인 신규 고객의 월 요금 20% 할인**
      - **가입 기간이 12개월 이하이고 월 요금이 높은 고객의 요금 15% 할인**

  - **이탈 방지 전략에 따른 데이터 수정2**
      - 위 데이터 수정을 기반으로 할인율 증가
   
   ### 🔍 결론 및 향후 과제
   - **결론**: 수정한 데이터로 모델 예측평가한 결과 이탈율이 **26.5**, **20.5%**, **17.6%** 으로 줄어드는것을 확인.

   - **과제**:
      - **지속적인 모니터링**: 고객 이탈 추이를 지속적으로 모니터링하고, 데이터 분석을 통해 전략의 효과성을 검증합니다.

      - **데이터 분석 강화**: 클러스터링 기법을 도입하여 위험군 고객을 식별하고, 이들에게 맞춤형 마케팅 전략을 적용합니다.

      - **고객 피드백 반영**: 고객 의견을 수렴하여 서비스 개선에 반영함으로써 고객 만족도를 높입니다.

<br>

## 4. 모델링

### 피처 선택 파이프라인

#### 1. **DataCleaning**:
- **역할** : 데이터 클리닝 (결측치 처리, 이상치 제거, 범주형 변환).
```python
class DataCleaning(BaseEstimator, TransformerMixin):
    def fit(self, X, y=None):
        return self

    def transform(self, X):
        # 데이터를 수정 가능하게 복사
        X = X.copy()

        # TotalCharges를 숫자형으로 변환
        X['TotalCharges'] = pd.to_numeric(X['TotalCharges'], errors='coerce')
        # SeniorCitizen을 범주형으로 변환
        X['SeniorCitizen'] = X['SeniorCitizen'].astype('category')

        # IQR 계산 및 이상치 처리
        Q1 = X[['MonthlyCharges', 'TotalCharges']].quantile(0.25)
        Q3 = X[['MonthlyCharges', 'TotalCharges']].quantile(0.75)
        IQR = Q3 - Q1
        lower_bound = Q1 - 1.5 * IQR
        upper_bound = Q3 + 1.5 * IQR
        X['TotalCharges'].fillna(X['TotalCharges'].median(), inplace=True) # => 0으로

        X['MonthlyCharges'] = X['MonthlyCharges'].clip(lower=lower_bound['MonthlyCharges'], upper=upper_bound['MonthlyCharges'])
        X['TotalCharges'] = X['TotalCharges'].clip(lower=lower_bound['TotalCharges'], upper=upper_bound['TotalCharges'])

        # customerID 열 제거
        if 'customerID' in X.columns:
            X = X.drop(columns=['customerID'])

        return X
```
#### 2. **FeatureEngineering**:
- **역할** : 다양한 피처 생성 (고객 유형, 계약 정보, 요금 관련 피처 등) - 유의미한 피처 45개.


#### 3. **ScaleAndTransform**:
- **역할** : 수치형 데이터 스케일링 및 다항 피처 생성, 범주형 데이터 인코딩.
- 수치형
 - 수치형 데이터 스케일링
 - 2차 다항식 변환을 통한 피처 생성
- 범주형
 - 범주형 데이터 인코딩

```python
class ScaleAndTransform(BaseEstimator, TransformerMixin):
    def __init__(self, degree=2):
        self.degree = degree
        self.preprocessor = None

    def fit(self, X, y=None):
        X = X.copy()

        continuous_features = X.select_dtypes(include=[np.number]).columns.tolist()
        categorical_features = X.select_dtypes(include=['object', 'category']).columns.tolist()

        numerical_pipeline = Pipeline([
            ('scaler', MinMaxScaler()),
            ('poly', PolynomialFeatures(degree=self.degree, interaction_only=False, include_bias=False))
        ])

        self.preprocessor = ColumnTransformer(
            transformers=[
                ('num', numerical_pipeline, continuous_features),
                ('cat', OneHotEncoder(drop='first', sparse_output=False, handle_unknown='ignore'), categorical_features)
            ]
        )

        self.preprocessor.fit(X)
        return self

    def transform(self, X):
        X = X.copy()
        X_processed = self.preprocessor.transform(X)
        feature_names = self.preprocessor.get_feature_names_out()
        feature_names = [name.replace(" ", "_") for name in feature_names]
        if X_processed.shape[1] != len(feature_names):
            raise ValueError("변환된 데이터의 열 개수와 피처 이름의 개수가 일치하지 않습니다.")

        return pd.DataFrame(X_processed, columns=feature_names)
```

#### 4. **CorrelationFilter**:
- **역할** : 상관관계가 높은 피처를 필터링하여 다중공선성 문제 해결, 기존 피처와 PolynomialFeatures를 사용하여 새로운 피처의 혼동 문제 해결
 - 상관 관계 행렬 계산
 - 상위 삼각 행렬을 이용한 피처 제거

#### 5. **SelectKBestWithNames**:
- **역할** : 상위 K개의 중요한 피처 선택.
 - F-통계량(분산 분석)을 사용하여 각 피처의 중요도를 평가
 - 중요도가 높은 상위 K개의 피처를 선택(파이프라인에서 설정)
   - 엄선된 노가다를 통한 135개의 피처 선택
 - 선택된 피처로 구성된 데이터셋 생성

```python
class SelectKBestWithNames(BaseEstimator, TransformerMixin):
    def __init__(self, score_func=f_classif, k=10):
        self.k = k
        self.score_func = score_func
        self.selector = SelectKBest(score_func=self.score_func, k=self.k)
        self.selected_features_ = None

    def fit(self, X, y):
        self.selector.fit(X, y)
        if isinstance(X, pd.DataFrame):
            self.feature_names_in_ = X.columns
        else:
            self.feature_names_in_ = np.arange(X.shape[1])
        self.selected_features_ = self.feature_names_in_[self.selector.get_support()]
        return self

    def transform(self, X):
        X_transformed = self.selector.transform(X)
        return pd.DataFrame(X_transformed, columns=self.selected_features_)
```

해당 파이프라인을 통해 교차검증 Fold 10개 중 공통으로 선택된 피처들을 최종 선택하여 최종 파이프라인에서 사용

### 최종 파이프라인

#### 1. **DataCleaning**:
- **역할** : 데이터 클리닝 (결측치 처리, 이상치 제거, 범주형 변환).

#### 2. **FeatureEngineering**:
- **역할** : 다양한 피처 생성 (고객 유형, 계약 정보, 요금 관련 피처 등).

#### 3. **ScaleAndTransform**:
- **역할** : 수치형 데이터 스케일링 및 다항 피처 생성, 범주형 데이터 인코딩.

#### 4. **FeatureSelection**:
- **역할** : 상위 K개의 중요한 피처 선택.
 - 피처 선택 파이프라인에서 각 Fold를 전부 비교하여 공동으로 선택된 피처들 중 가장 성능이 좋은 피처를 최종 선택한 피처들로 선택


### 모델 생성 및 하이퍼 파라미터 튜닝

#### 1. 모델 정의 및 설정
#### 2. 각 모델에 대해 RandomSearch를 통해 넓은 범위에서 1차 HPO 수행.
#### 3. Optuna를 통해 1차 HPO에서 나온 하이퍼파라미터를 바탕으로 세부 범위에서 2차 추가 최적화 진행.
#### 4. 최적화된 모델을 저장

### 교차 검증 및 Voting, Stacking 모델 선택 평가

#### 1. **모델 불러오기**: 저장된 11개의 모델을 `.pkl` 파일에서 불러옴.
#### 2. **교차 검증**: 각 모델에 대해 10번 교차 검증을 수행하여 F1 스코어 계산.
#### 3. **Voting Classifier**: 소프트 보팅 및 하드 보팅 앙상블 모델을 구성하고 교차 검증 평가.
#### 4. **Stacking Classifier**: 스태킹 앙상블 모델을 구성하고 교차 검증 평가.
#### 5. **최적 모델 선택**: 총 3개의 모델 중 성능이 더 높은 모델을 최종 모델로 선택하고 저장.
#### 6. **ROC Curve 및 혼동 행렬 시각화**: 최종 모델의 성능을 시각적으로 평가.


## 6. 기술 스택

| Language        | Framework          | DB            | Devops       |
|---------------|-----------------|--------------------|------------------|
| ![Python](https://img.shields.io/badge/Python-3776AB?style=for-the-badge&logo=python&logoColor=white) | ![Django](https://img.shields.io/badge/Django-092E20?style=for-the-badge&logo=django&logoColor=white) |![MySQL](https://img.shields.io/badge/MySQL-4479A1?style=for-the-badge&logo=mysql&logoColor=white) |  ![Docker](https://img.shields.io/badge/Docker-2496ED?style=for-the-badge&logo=docker&logoColor=white) |

## 7. 오류 리포트

### 모델 연동 및 로드 과정
1. <b>모델 연동 문제<b>
- **설명**: 모델 연동 중 전처리 코드 경로를 인식하지 못하는 문제가 발생
- **문제 원인**: 학습 모델이 저장된 `.pkl` 파일을 불러올 때, 모델이 학습된 환경과 현재 환경이 달라 오류가 발생
- **해결 방법**: sys.module의 "__main__" 메서드에 해당 모델을 정의하여 필요한 클래스들에 접근 가능하도록 수정해 문제를 해결

2. <b>모델 로드 문제<b>
- **설명**: `.pkl` 파일에서 모델을 불러올 때, 데이터 형식이 numpy 배열로 로드되는 문제가 발생
- **문제 원인**: 모델을 저장할 때는 `joblib` 라이브러리를 사용했으나, 불러올 때는 `pickle` 라이브러리를 사용해 발생한 문제
- **해결 방법**: 저장할 때 사용한 것과 동일한 `joblib` 라이브러리를 사용해 파일을 로드하여 문제를 해결

3. <b>피처 선택 문제<b>
- **설명**: 초기 파이프라인에서 각 Fold마다 선택되는 feature가 달라 교차검증 시 각 Fold의 feature 불일치 문제가 발생
- **문제 원인**: 각 Fold마다 선택되는 feature가 달라 최종적으로 선택되는 feature가 달라져서 문제가 발생
- **해결 방법**: 각 Fold마다 선택되는 feature를 기록하고 공통으로 뽑힌 feature를 선별해 feature selection을 진행하여 해결

### 깃허브 협업 과정
1. <b>깃허브 push 오류<b>
- **설명**: 모델 파일이 포함된 브랜치에서 push 시도 중 오류 발생
- **문제 원인**: 파일 크기가 100MB를 초과해 push가 불가, 파일을 제외해도 같은 오류 발생
- **해결 방법**: 로컬에서 새 프로젝트를 생성해 push 문제 해결


### 데이터 분석 및 모델링 과정
1. <b>클러스터링 분석</b>
- **설명**: K-Means 클러스터링 PCA결과가 Colab이랑 Local에서 다르게 시각화
- **문제 원인**: Colab(3.10)과 Local가상환경(3.12) Python버전이 달라 numpy, panda, sscikit-learn, matplotlib 등 모든 버전이 다름
- **해결 방법**: Local 가상환경을 다운그레이드 시키면 해결이 될거같으나 이미 프로젝트가 많이 진행되어 해결못하고 Colab 분석내용으로 사용하기로 결정

## 8. 팀원 소감

- **박중헌**: 피처 선택 과정에서의 피처 처리 문제가 다수 발생하며, 교차검증을 진행시에 대한 파이프라인 구축 및 모델을 django 프로젝트에 연동하는 과정에서 많은 어려움을 겪었다. 모델을 연동하는 방법을 찾아보면서 모델을 연동하는 방법을 익힐 수 있었다. pickle 파일의 세부 구조를 뜯어볼 수 있었고, joblib과 pickle의 성능 비교 및 분류 문제에서 모델을 선택하는 방법을 익힐 수 있었다.
- **김원철**: 그 동안 수업에서 쥬피터를 통해서 결과값만 확인 해 보다가 실제 모델을 뽑고 해당 모델에 수정한 피처를 넣고 결과가 나오고 하는것들을 보면서 모델을 정신없이 배울때 보다 재미있었던 것 같습니다. 이를 통해서 재미있는 ai웹서비스를 만들어 볼 수 있겠다는 자신감이 조금은 생긴것 같습니다.
- **문건우**: 파일화된 모델을 불러오는게 생각했던 것보다 쉬운 작업이 아니라는 걸 알았고, 이걸 또 잘 해결하신 팀원분들이 정말 대단한 것 같습니다. 며칠 동안 늦은 시간까지 작업하시느라 고생하셨습니다!!
- **정재현**: 이번 단기 프로젝트는 오랜만에 그동안 배웠던 데이터베이스, Django, css 등등을 다시 사용하고 숙련도를 익힐 수 있었던 좋은 기회였습니다. 그리고 좋은 팀원들과 협업할 수 있어서 즐거웠습니다.
- **이준석**: 항상 1인분만하자라는 생각으로 하는데 생각보다 쉽지않았습니다. 그래도 팀원들이 많이 도와줘서 많이 배운거같습니다.

